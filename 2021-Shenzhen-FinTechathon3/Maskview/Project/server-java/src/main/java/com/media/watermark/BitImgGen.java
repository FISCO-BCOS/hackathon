package com.media.watermark;

/**The input matrix is transformed into a pattern diagram and the sequences of
 * the maximum quantizer and the minimum quantizer are generated
 @Time 2020-04-20 14:49:01
 */
public class BitImgGen {

    private double[][] bit_img;                                                                                         //bitmap image
    private double[][] max_quan;                                                                                        //Maximum quantizer sequence
    private double[][] min_quan;                                                                                        //Minimum quantizer sequence

    public double[][] getBit_img(){
        return this.bit_img;
    }

    public double[][] getMax_quan() {
        return max_quan;
    }

    public double[][] getMin_quan() {
        return min_quan;
    }

    /**
     * @param a bitmap image
     * @param b Maximum quantizer sequence
     * @param c Minimum quantizer sequence
     */
    public BitImgGen(double[][] a, double[][] b, double[][] c){
        this.bit_img=a;
        this.max_quan=b;
        this.min_quan=c;
    }

    public static BitImgGen BitImgGen(double[][] matrix){
        int m = 4;
        int n = 4;
        double w1 = 0.2716;                                                                                             //diffusion coefficient
        int w2 = 1;                                                                                                     //diffusion coefficient
        int matrixRow=matrix.length;
        int matrixCole=matrix[0].length;

        int[][] pos = {{3,2},{0,3}, {1,1}, {2,3},                                                                       //Coordinate matrix
                {1,2}, {2,0},{0,2},{2,2},
                {0,0},{2,1}, {3,3},{0,1},
                {1,3},{3,0},{1,0},{3,1}};
        int[][] prority = {{8,11,6,1},                                                                                  //Priority matrix
                {14,2,4,12},
                {5,9,7,3},
                {13,15,0,10}};

        int sub_m =matrixRow/m;
        int sub_n =matrixCole/n;

        double[][][] sub_img = new double[m][n][(sub_m*sub_n)];                                                         //Image block sequence
        double[][][] sub_bit = new double[m][n][(sub_m*sub_n)];                                                         //Bitmap image sequence generated by image block sequence
        double[][] bit_img=new double[(sub_m*m)][(sub_n*n)];                                                            //Bitmap image

        double[][][] t=new double[m][n][(sub_m*sub_n)];
        double[][][] e=new double[m][n][(sub_m*sub_n)];
        double[][][] s=new double[m][n][(sub_m*sub_n)];

        double[][][] sumw=new double[m][n][(sub_m*sub_n)];
        double[] avg=new double[(sub_m*sub_n)];                                                                         //Average sequence
        double[] maxv=new double[(sub_m*sub_n)];                                                                        //Maximum sequence
        double[] minv=new double[(sub_m*sub_n)];                                                                        //Minimum sequence

        int count = 1;
        for (int i=0;i<sub_m;++i){
            for(int j=0;j<sub_n;++j){

                //Extract pixel block
                double[][] tmp_img=new double[m][n];
                for (int k=0;k<m;++k){
                    for (int l=0;l<n;++l){
                        tmp_img[k][l]=matrix[i*m+k][j*n+l];
                    }
                }
                //Image block sequence
                for (int k=0;k<m;++k){
                    for (int l=0;l<n;++l){
                        sub_img[k][l][count-1]=tmp_img[k][l];
                    }
                }

                avg[count-1]= Operation.mean(tmp_img);                                                                   //Average sequence
                minv[count-1]= Operation.min(tmp_img);                                                                   //Maximum sequence
                maxv[count-1]= Operation.max(tmp_img);                                                                   //Minimum sequence

                count++;
            }
        }

        double[][][] v=sub_img.clone();

        for (int i=0;i<pos.length;++i){
            //The coordinates of the diffusion center
            int x=pos[i][0];
            int y=pos[i][1];
            double sum=0;
            //Calculate the diffusion coefficient corresponding to this point
            if(x>0){
                if(y>0){
                    DiffuseGen pointDiffuse= DiffuseGen.diffusegen(x,y,x-1,y-1,prority,avg,maxv,minv,v,sum,sumw,w1,e,t);
                    sum=pointDiffuse.getSum();
                    sumw=pointDiffuse.getSumw();
                }if(y+1<n){
                    DiffuseGen pointDiffuse= DiffuseGen.diffusegen(x,y,x-1,y+1,prority,avg,maxv,minv,v,sum,sumw,w1,e,t);
                    sum=pointDiffuse.getSum();
                    sumw=pointDiffuse.getSumw();
                }
                DiffuseGen pointDiffuse= DiffuseGen.diffusegen(x,y,x-1,y,prority,avg,maxv,minv,v,sum,sumw,w1,e,t);
                sum=pointDiffuse.getSum();
                sumw=pointDiffuse.getSumw();
            }
            if (x+1<m){
                if (y>0){
                    DiffuseGen pointDiffuse= DiffuseGen.diffusegen(x,y,x+1,y-1,prority,avg,maxv,minv,v,sum,sumw,w1,e,t);
                    sum=pointDiffuse.getSum();
                    sumw=pointDiffuse.getSumw();
                }if (y+1<n){
                    DiffuseGen pointDiffuse= DiffuseGen.diffusegen(x,y,x+1,y+1,prority,avg,maxv,minv,v,sum,sumw,w1,e,t);
                    sum=pointDiffuse.getSum();
                    sumw=pointDiffuse.getSumw();
                }
                DiffuseGen pointDiffuse= DiffuseGen.diffusegen(x,y,x+1,y,prority,avg,maxv,minv,v,sum,sumw,w1,e,t);
                sum=pointDiffuse.getSum();
                sumw=pointDiffuse.getSumw();
            }
            if (y>0){
                DiffuseGen pointDiffuse= DiffuseGen.diffusegen(x,y,x,y-1,prority,avg,maxv,minv,v,sum,sumw,w1,e,t);
                sum=pointDiffuse.getSum();
                sumw=pointDiffuse.getSumw();
            }
            if (y+1<n){
                DiffuseGen pointDiffuse= DiffuseGen.diffusegen(x,y,x,y+1,prority,avg,maxv,minv,v,sum,sumw,w1,e,t);
                sum=pointDiffuse.getSum();
                sumw=pointDiffuse.getSumw();
            }

            for (int j=0;j<s[0][0].length;++j){
                s[x][y][j]=sumw[x][y][j]/sum;
                v[x][y][j]=sub_img[x][y][j]+s[x][y][j];
            }
        }
        //Converts a sequence of pixel blocks into a sequence of bitmaps
        for (int i=0;i<v.length;++i){
            for (int j=0;j<v[0].length;++j){
                for (int k=0;k<v[0][0].length;++k){
                    if (v[i][j][k]>=avg[k]){
                        sub_bit[i][j][k]=1;
                    }
                }
            }
        }
        count=1;
        //Generate a bit-mode matrix
        for (int i=0;i<sub_m;++i){
            for (int j=0;j<sub_n;++j){

                for (int k=0;k<m;++k){
                    for (int l=0;l<n;++l){
                        bit_img[i*m+k][j*n+l]=sub_bit[k][l][count];
                    }
                }
            }

            count++;
        }

        double[][] max_quan = Reshape.transposition(Reshape.reshape1(maxv,(int)sub_n,(int)sub_m));                      //Maximum sequence
        double[][] min_quan = Reshape.transposition(Reshape.reshape1(minv,(int)sub_n,(int)sub_m));                      //Minimum sequence
        return new BitImgGen(bit_img,max_quan,min_quan);
    }
}
