# 1. 项目背景

## 1.1 背景分析

随着数字经济的高速发展，数据要素已经逐步融入生产生活的各个环节，与土地、劳动力、资本、技术等并列，成为重要的生产要素之一，深刻影响并重构着经济社会结构。为应对这一变革，中国于2024年初组建国家数据局，研究并实施“数据要素X”行动，加快推进数据基础设施的建设工作[1]。数据基础设施作为让数据“供得出、流得动、用得好”的关键载体，不仅推动着数据安全可信的流通，更是实现数字服务高效利用的重要保障。

然而，在云计算、大数据、人工智能等新兴技术的推动下，数字服务的部署方式已发生改变。用户通过诸如Dropbox和Apple Pay等互联网服务商进行数据交互[2]，但这种分布式环境也带来了新的挑战。智能设备的激增使得连接到互联网的设备数量剧增，而这些设备往往部署在不安全的环境中，使用它们的用户也并非完全可信。因此，如何确保分布式服务的安全连接成为了当下亟待解决的课题。

为此，基于密码学的认证方案应运而生，成为应对这些挑战的第一道防线。身份认证、数字签名交换等方案为数据安全提供了坚实保障。传统的身份认证方案可以分为两大类，基于对称密钥的Kerberos协议和基于公钥密码学的公钥基础设施（Public key infrastructure, PKI）技术。Kerberos 协议通过口令认证的方式实现对用户的认证；PKI技术，通过数字证书映射绑定以证明用户身份。然而，尽管有这些防护措施，数据安全形势依然严峻。据苹果公司近期发布的数据泄露报告，2023年前九个月就有3.6亿人的敏感数据遭泄漏，相比2022年全年高出20%。这一数字凸显了全球企业所面临的数据安全危机。

综上所述，数据安全已成为数字经济时代的重要议题。然而，传统的身份认证方案往往伴随着第三方的存在，中心化的认证中心难免成为黑客的首要目标，这也导致用户数据泄露事件频繁发生。传统数字交易存在的中心化及隐私保护问题日益突出，学者们尝试利用不同的技术解决现有问题。

2008年，中本聪一篇比特币[3]论文诞生了区块链这一项革命性的技术。区块链凭借去中心化、透明可追溯、防篡改等特性被许多学者引入，用于解决传统中心化认证方案存在的安全问题。

而基于区块链的去中心化认证方案作为基石，可以支撑其他研究，例如公平的数字签名交换，基于Kerberos的身份认证方案改进等的具体实施。同时出于对数字设备的性能消耗考虑，如何实现数字设备之间的高效认证也是一项挑战。因此，亟需引入区块链技术及高效的密码学方案改进优化现有的身份认证方案。

基于以上背景，本课题通过研究代理签名、属性基密码等加密技术，深入进行基于区块链的去中心化认证方案的研究与实现，对于解决数字设备的安全认证，实现去中心化的安全数据共享提供新思路，也为数据安全提供理论支撑，促进数据互联互通行业发展。



## 1.2 国内外相关研究现状

### 1.2.1 去中心化身份认证

中心化身份认证是当前最常见的方案，然而一旦掌控一切的中央服务器出现故障，身份识别机制就会彻底失效。区块链技术可以使身份识别机制去中心化，而不再依赖中心服务器[29]。 

在ARPKI中，Basin等人[30]引入了多个认证中心（Certificate Authority，CA），以串行模式签名和验证证书。2014年，Fromknecht等人[31]提出了第一个基于区块链的PKI机制CertCoin。通过公开的账本记录将用户身份与公钥证书映射，从而实现PKI的去中心化。任何用户都可以查询证书的颁发过程。在此基础上，Axon等人[32]改进了CertCoin模型，并提出了一种基于区块链的PKI隐私保护技术，名为PB-PKI（基于隐私感知区块链的PKI）。不同于传统的PKI通过公钥直接连接用户的真实身份，而是通过离线密钥保护在线密钥，避免用户暴露真实身份。

Kubilay等人[33]提出了一种基于区块链的具有证书透明度的新的PKI模型，CertLedger。在CertLedger中，所有TLS客户端都可以验证日志的最终状态，因此不可能进行分裂世界攻击。此外，CertLedger还提供了证书撤销和受信任的CA管理流程的透明度。

CertChain[34]提供了一个具有证书操作历史可追溯性和撤销验证的公共审计PKI系统。为了解决被撤销的证书存储规模问题并保护客户端隐私，作者提出了一种可伸缩的证书撤销隐私保护PKI系统，PBCert。与上述基于区块链的分布式PKI系统相比不同的是，Matsumoto等人[35]研究了在给定的PKI系统中，通过自动化激励机制来抵御CA非法行为。

Hammi等人[36]提出了一个分布式系统，称为“信任气泡”，保证设备的可靠识别和认证，并保护数据的完整性和可用性。为了实现这一点，他们的方法依赖于区块链技术提供的安全优势，并创建安全的虚拟信任域——气泡。

对于分布式PKI区块链架构，Hari和Lakshman[37]实现了DNS映射中边界网关协议（BGP）的路由传播和身份验证，以防止恶意节点攻击。Faisca和Rogado[38]解决了个人云环境中的身份管理和证书管理问题，提高了认证的效率和安全性。

ModelChain[39]应用区块链分布式PKI在无线传感器网络中建立信任域。而Zhang等人[40]通过区块链实现安全认证，基于智能合约，以及后端软件保护扩展（SGX）可信硬件实现。Bassam等人[41]通过观察当前的X.509认证标准，只允许仅针对用户的身份颁发证书，但可以记录细粒度的身份认证证书属性信息，从而增加了属性信息的身份验证。在这种方法中，如果用户的身份信息经过身份验证，则其身份的相应属性也被认为是可信的，实现了用户身份和用户属性之间的信任交换。

Fabric-iot[42]是第一个通过基于区块链的ABAC模型提供细粒度访问控制的开源方案。Yao等人[43]提出了一个基于联盟链的跨域证书管理系统，CD-BCM，以简化证书撤销检查的过程。Dong Li等人[44]则提出了一种基于联盟链的车联网跨域认证协议。BTCAS[45]提出了一种基于区块链技术的彻底的跨域认证方案，可被采用完全不同设置的不同领域的参与者使用。Zhao等人[46]提出了一种基于区块链的分布式跨域身份认证协议（BC-CDIA）。将区块链证书的生成过程和哈希的存储过程放于注册过程中，减少AS和CA的验证过程，验证哈希而不是证书的签名，提高了跨域认证的效率。AAGrid[47]提出了一种基于联盟链及公钥密码的方案实现了智能电网环境下终端的身份认证和资源授权。

至于Kerberos改进的方案，Hena等人[48]提出了一种结合区块链技术和阈值密码系统的改进的方案。根据他们的描述，多个票单授予服务器（TGS）的部署确保了系统的可用性，并在很大程度上避免了单点故障的问题，但在该方案中没有具体实现细节。此外，他们在另一项研究中提出了一种新的基于区块链的三层认证框架[49]。设计了一个实用的拜占庭容错（PBFT）区块链网络来取代KDC的本地数据库。文献[48]解决了诸如单点故障、证书隐私和密码猜测攻击等问题。2022年，Li等人[50]针对用户和服务器之间的密钥协议提出了一种基于区块链的双向认证方案。

### 1.2.2 数字签名交换

公平交换问题指的是有两个相互不信任的当事人A和B想要交换物品，交换协议应该确保双方获得交换物品或最终不交换。随着数字经济的蓬勃发展，许多互联网上的在线业务如数字媒体，合同签署等，可能涉及双方的物品公平交换[4]。许多数字物品的所有权往往通过交换相应的数字签名来转移，因此公平交换问题的主要问题便是数字签名交换。有许多研究提出了公平的数字签名交换协议。然而，它们中的大多数都需要一个值得信任的第三方(TTP)，而TTP的安全性受限。

为了解决可信第三方（TTP）导致的安全问题，Park等人[5]提出了一种基于RSA签名方案的协议。在此方案中，发送方只将部分私钥和公钥发送给TTP进行验证，以避免第三方推断出整个私钥。然而Dodis等人[6]指出Park的方案避免不了诚实但好奇的仲裁者推断出签名者的秘钥，因此存在推理缺陷。具体地，Huang等人[7]指出Park的协议无法抵御推断攻击。即一个好奇的TTP可以从它接收到的信息中推断出整个私钥。

为了保证协议的安全性，Huang和Wang等人[8]据此对协议进行了改进。Huang等人针对不可信任的第三方提出P2OFE，争议解决之后仍能保证签名安全。Wang 通过应用零知识证明和陷门承诺方案，隐藏了发送到TTP的部分公钥，而不是同时发送部分公钥和私钥。然而，该方法极大地增加了计算成本和通信成本。Zhang等人[9]首先提出了抗滥用（abuse-free）的概念，并基于离散对数实现了该属性。

针对TTP的消耗问题，Zhai等人[10]提出了基于低存储TTP的抗滥用的两方电子合同签署协议。2019年，CSP-E2[11]提供了一种减少TTP存储的方法。然而，集中式TTP的存在仍然是一个瓶颈，很可能遭遇单点故障。

并发签名[12]的概念由Chen等人提出。并发签名允许两个实体生成两个签名，签名者的身份不被第三方感知，直到一方发布附加信息。该方案基于环签名[13]和指定验证者签名[14]，不依赖TTP就可以实现签名交换。Susilo等人进一步提出了一个完美的并发签名方案[15]：第三方无法推断是谁签署了两个签名中的哪一个。随后，Wang等人[16]指出，Susilo等人提出的方案实际上并不是并发的，并提出了一种攻击，使原始签名者能够释放一个精心准备的keystone。相对的，他们提出了一种有效的抵御这种攻击的方法，使改进后的方案真正适合于并发签名。

Ferradi等人的公平合同签名方案[17]可以在没有keystones的情况下完成两方签名交换，保证了法律公平和抗滥用。然而，该方案需要双方之间的多重交互，造成了一定的安全风险。综上，数字签名交换面临的障碍之一是其效率问题。现有的相关协议很难同时保证效率的同时，也保证其他特性。

近年来，区块链技术被广泛应用于解决传统数据存储的中心化问题。2014年，Danushka等人[18]提出了一种基于比特币网络的用于复杂交易的乐观公平交换电子商务协议。该方案中交换的物品不会向可信第三方泄露。Ferrer Gomila等人[19]提出了第一个基于比特币的合同签订解决方案。该解决方案在成本、效率和符合安全要求方面取得了改进，但也有局限性。

Huang等人[20]提出了一种基于可验证的加密签名和区块链的三方公平交换协议。Zhang等人[21]同样使用可验证加密签名方案。该方案尝试通过设计以太坊智能合约[22]，实现完全去除可信第三方的存在。通过将质押代币在智能合约中来确保公平，作弊玩家将受到惩罚，即被没收代币。然而该方案使用了算力消耗较大的双线性配对操作。Ferrer Gomila等人在最新的研究中[23]使用拓展椭圆曲线签名方案，该方案清晰地将总体流程分为链上和链下两部分，并强调区块链只用于当合同签署出现争议时。

综上可见，从参与方数量出发，现有研究可以分为两方签署，多方签署两大类。长久以来，大多协议均是针对双方合同签署。随着签署方数量的增加，协议的通信成本和复杂度急剧增加。曹等人[24]基于无证书的高效聚合签名方案，提出一个高效的多方合同签署协议。协议中在区块链上仅公开签署方的临时密钥以减少系统开销。然而杨等人[25]通过安全性分析发现，该方案无法抵抗替换公钥攻击和内部签名者的联合攻击。为了解决上述安全缺陷，提出一个改进的无证书聚合签名方案。新方案不仅在随机预言模型下基于计算性Diffie-Hellman问题满足不可伪造性，同时也能抵抗联合攻击。

Payeras-Capellà等人[26]提出了去除可信第三方的基于ECC的多方数字合同签署协议，虽然没有使用昂贵的双线性配对操作，但使用了零知识证明技术保证合同的隐私，开销大。Zhang等人[27]使用并发签名方案和Schnorr签名设计了一个高效的多方电子合同签署协议，然而方案中存在NTO第三方。Zhang等人[28]提出了三方合同认证和签字的方法，将加密合同上链，同时使用异构存储在本地数据库上保留了原始合同以此减轻存储压力。



## 1.3 相关理论基础

### 1.3.1 区块链

2008年，区块链作为比特币的基础技术诞生。中本聪提出的区块链的概念，是一种点对点分布式账本技术，狭义的“区块链”可以理解为由哈希链接的带时间戳的区块序列组成。尽管颇具复杂性，区块链却以去中心化、数据透明和可追溯性而闻名。如下是区块链所具有的几个关键特征：	

首先，每个节点都拥有账本的副本，并通过共识达到一致。各个节点通过如工作量证明(PoW)和权益证明(PoS)等共识算法维护这个账本，以确保所有节点之间账本的一致性。

其次，不可篡改。通过使用哈希实现默克尔树，区块之间通过哈希指针链接，任意的篡改都会破坏这种链式结构。链上的交易数据不可伪造，防篡改因此实现。

最后，智能合约。智能合约可以简单理解为在链上运行的计算机程序，智能合约的诞生使成千上万的开发人员参与到去中心化应用的建设中，推动区块链进入可编程的新时代。随着技术的发展，新的区块链平台出现。以太坊[22]使区块链可使用智能合约进行编程。智能合约并不是一个新概念，它最初是Nick Szabo的研究中[51]提出的，它代表了由参与者执行的数字承诺。当触发条件被激活时，区块链中的智能合约可以自动执行。此外，它是无TTP的，不可逆的和可追溯的。

为了使区块链可编程，以太坊提供了图灵完备的编程语言Solidity[52]。Solidity等高级语言编写的智能合约通过沙箱——太坊虚拟机（EVM）编译生成字节码。它们最终会被转换为由以太坊的所有节点/矿工运行的交易。要通过EVM在区块链上运行智能合约，用户应该在以太坊上支付Gas。因此，开发者都趋向于实现低Gas成本的操作，以降低交易付出的开销。智能合约的生命周期有三个部分，即创建、部署和执行[53]。

智能合约创建：在这个阶段，参与者开始设计智能合约并为其编写代码。所形成的代码将被验证，并应由参与者达成一致。

智能合约部署：在此阶段，智能合约代码将被编译并部署到区块链中。合约的部署实质是向区块链发送一个交易，随后由以太坊中的节点/矿工进行验证和确认，将合约作为区块的一部分打包到链上。

智能合约执行：要执行已部署的智能合约所提供的功能，可以向区块链发送一个特殊的交易。在交易中，数据根据智能合约的接口构建，并将激活触发条件。以太坊中的节点/矿工将验证和确认交易，智能合约的状态将更改。

随着时间的推移，区块链技术已经在金融科技、供应链管理、产品生命周期，版权保护等领域得到了广泛应用。

### 1.3.2 身份认证方案

#### 1.3.2.1 Kerberos认证协议

Kerberos 是一种基于对称密码实现的身份认证协议。Kerberos名称来源于西方神话中防守地狱之门的“地狱三头犬”。该协议由麻省理工学院研发，可提供域内身份认证和单点登录等，被广泛应用于各类分布式环境中。所谓“三头”，形象地道出了Kerberos 认证协议定义的三个主要角色，分别是：客户端C、服务器V和密钥分发中心KDC。其中，KDC作为可信第三方存在，它由三个组件组成，分别是：认证服务器AS、数据库DB和票据授予服务器TGS。

三个交换事务，分别是：认证服务交换(AS-EX)，票据授予服务交换(TGS-EX)，应用交换(AP-EX)。它的目的是分发密钥和凭证，同时提供身份验证。关于每个参与者的信息，如他们的 ID 和密钥，都存储在 KDC 的数据库中。

![img](wps1.jpg) 

图1 Kerberos协议认证流程图

Kerberos V5[54]的认证过程如图1所示。最初，每个客户端在 KDC 中注册，他们的密钥被派生到 AES 密钥中。然后 KDC 对每个客户端的 AES 密钥进行加密，并将其存储在其数据库中。认证服务交换(AS-EX)通常用于启动登录会话并为票据授予服务器获取凭证。这些凭证随后用于为其他服务器获取凭证，而不需要进一步使用客户端的密钥。票据授予服务交换(TGS-EX)用于获取给定服务器的称为“服务票据”(ST)的身份验证凭证。应用交换(AP-EX)是客户端和服务器相互认证的最后一步，服务器验证ST。如果所有检查，如ID、时间戳和nonces，成功且没有任何错误，则建立客户端和服务器之间的身份验证，并开始客户端和服务器之间的服务会话。如果发生任何错误，客户端将以“KRB-ERR”消息响应服务器。通过AS-EX的单点登录方式，合法用户可以在不显式身份验证的情况下安全地执行TGS-EX和AP-EX。有关消息格式和加密的更多细节，请参见表1[55]。

尽管Kerberos在身份认证中扮演着重要角色，其存在的一些问题：如中心化造成的单点故障，重放攻击，DDoS，黄金/白银票据等并没有得到很好的解决。

表1 Kerberos协议中的报文

| 报文        | 通信方向  | 报文内容                                                     |
| ----------- | --------- | ------------------------------------------------------------ |
| **AS-REQ**  | **C→AS**  | **{ IDc \|\| IDtgs \|\| Time-exp \|\| Nonce\|\| Kc{TimeStamp}}** |
| **AS-REP**  | **AS→C**  | **Kc{Kc,tgs\|\|IDtgs\|\|Time-exp \|\|Nonce\|\|TimeStamp\|\| TGT}** |
| **TGS-REQ** | **C→TGS** | **IDv,Time-exp,Nonce\|\| TGT \|\|Authenticator1**            |
| **TGS-REP** | **TGS→C** | **Kc,tgs{Kc,v,IDc,IDv,ST, Time-exp,Nonce,TimeStamp}**        |
| **AP-REQ**  | **C→S**   | **IDc,IDv,TimeStamp, ST\|\|Authenticator2**                  |
| **AP-REP**  | **S→C**   | **Kc,v{IDc,IDv,TimeStamp}**                                  |

#### 1.3.2.2 基于PKI的认证

PKI，全称公钥基础设施(Public KeyInfrastructure)，是一种由认证中心（Certification Authority, CA）支配的基于公钥密码学实现网络安全服务的机制。该安全通信机制提供了一系列的标准安全组件，由数字证书、认证中心（CA）、注册中心（RA）、证书数据库等组成，支持身份认证、消息的完整性、机密性和不可否认性，为网络应用提供可靠的安全保障。

数字证书：认证中心或称证书授权中心，为设备颁发一个强绑定的数字证书。证书标准一般依据X.509 v3，其中包含了公钥和被验证过的数字签名。接收方收到数据发送方发送的数字签名和证书时，可在证书中获取公钥从而验证发送方身份的有效性。一个证书的全生命周期包括：证书的申请、审批、生成/签发、发布，再到证书更新、查询和撤销、归档。

注册审核机构（RA）：实现 PKI体制中的数字证书申请、注册和审核。

认证中心（CA）：作为权威机构，实现对数字证书的申请、审批、发放，再到证书的更新、查询和撤销等环节管理。

证书数据库：存储已签发的证书及公钥，用户从数字证书库查询证书。

总体上看，用户预先存储有自己所信任的根CA自签名证书，用来验证与之通信的其他PKI 用户的证书链，从而可信地获得其他用户的公钥，用于各种安全服务。

## 1.4 应用前景分析

去中心化Kerberos安全服务管理方案（DKSM）在多个领域具有广泛的应用前景： 

* 物联网（IoT）安全：随着物联网设备数量的急剧增长，确保这些设备之间的安全通信变得至关重要。DKSM提供了一种去中心化的身份认证和访问控制机制，能够有效防止未授权设备访问网络资源，确保物联网环境的安全性。 
* 智能家居：智能家居系统中，各类设备和应用程序需要进行身份认证和授权。DKSM可以提供一种安全、可靠的认证机制，确保只有经过授权的用户才能访问和控制智能家居设备，提高家庭安全性。 
* 智慧城市：在智慧城市建设中，涉及到大量的分布式数据和服务管理。DKSM可以为智慧城市中的各种应用提供安全认证和访问控制，防止数据泄露和非法访问，保障城市管理系统的安全运行。 
* 云计算和边缘计算：在云计算和边缘计算环境中，数据和服务的安全性至关重要。DKSM通过去中心化的方式，实现了对用户身份的认证和对数据的细粒度访问控制，能够有效防止数据泄露和篡改，提升云计算和边缘计算环境的安全性。 

⚫ 金融科技：在金融科技领域，用户身份认证和数据安全是关键问题。DKSM可以为金融科技应用提供高效、安全的身份认证机制，确保金融交易的安全性，防止欺诈和数据泄露。 

⚫ 医疗健康：在医疗健康领域，患者数据的隐私保护和访问控制至关重要。DKSM通过基于属性的加密机制，实现了对患者数据的细粒度访问控制，确保只有经

过授权的医疗人员才能访问敏感数据，保障患者隐私安全。 

综上所述，去中心化Kerberos安全服务管理方案（DKSM）通过结合区块链技术和密文策略属性基加密（CP-ABE）方法，为各类分布式环境提供了一种安全、高效的身份认证和访问控制解决方案，具有广泛的应用前景和重要的实际意义。

# 2. 项目简介

本作品针对Kerberos身份认证方案存在的中心化问题，链上信息隐私保护问题，提出了基于区块链的去中心化Kerberos身份认证方案（DKSM）。设计智能合约实现更高程度的去中心化，免除 KDC 的中心化存储；尝试寻找细粒度访问控制方案，对链上信息，如KDC密钥进行隐私保护和细粒度访问控制；基于密文策略的属性基密码（CP-ABE） 与对称密码AES进行结合，实现链上信息隐私保护及细粒度访问控制；设计基于区块链的时间同步应答响应机制，实现对重放攻击的抵御。基于Python实现了协议，并设计了Solidity智能合约。

其设计逻辑包括以下三方面: 

（1）与区块链结合紧密。**设计智能合约**实现更高程度的去中心化，免除KDC的中心化存储；基于区块链账户地址实现去中心化身份，消除了重复生成公钥对的需要。

（2）**采用AES和CP-ABE**作为隐私保护的密码机制。采用FABEO属性基加密算法，密文短，效率高，实现对KDC密钥的细粒度访问控制；

（3）实现对多数传统攻击的抵御。为了抵抗重放攻击，**设计**一种基于区块链的时间同步解决**方案BCTs-Nc**；同时，区块链技术使DKSM实现对中间人攻击及白银票据，黄金票据的抵御。 

## 2.1 系统模型

本作品取名DKSM（Decentralized Kerberos Secure Service-Management），即去中心化Kerberos安全服务管理协议，保留了原始Kerberos方案中的客户端，服务器以及密钥分发中心KDC三个角色，及三个交换过程。传统的KDC存在中心化问题，在KDC数据库中存储着协议参与者的私钥，一旦私钥泄露，会危及服务安全管理。因此，我们借助区块链技术引入智能合约进行存储、逻辑判断，实现去中心化的KDC。所有的交流消息都会被存进区块链智能合约中。

此外，DKSM融合基于密文策略的属性基加密以实现数据细粒度访问控制，对链上数据进行隐私保护。与传统的安全服务管理相比，新的方案具有以下特点：首先，去中心化，这意味着不再依赖于单一的中心机构来管理安全服务。其次，可追溯性，可以追踪到每一次操作的来源和过程。再者，隐私保护，用户信息不被泄露。最重要的是，DKSM实现了3As原则，即提供了访问控制、授权和审计三大功能。确保安全服务的全面性和可靠性。由于传统Kerberos不提供授权功能，DKSM将授权简化为包含用户ID和权限ID，操作权限的权限列表来表示权限范围。最后，通过在以太坊测试网络和FISCO的实验表明DKSM方案的可行性。

![img](wps2.jpg) 

图3 去中心化Kerberos身份认证设计总览图

DKSM的总览图如图3，整体协议流程如下：

①　要加入Kerberos的域中，必须首先通过将其公共信息上传到智能合约注册。

②　授权机构根据制定的访问策略**S**生成ABE密钥对**PK、MSK**。验证者如果没有正确的属性，将无法获取**Kkdc**正确地解密任何用户的秘密密钥。

③　接下来，KDC调用相应的初始化函数并上传用户数据。

④　为了登录，客户端在发起认证事务的同时，必须发送AS-REQ消息，触发相应的函数如**get_nonce()、check_nonce()**等以抵御重放攻击。由智能合约验证客户端的合法性。

⑤　如果客户端是合法的，则存储AS-REQ并等待票据授予服务器TGS检索它。当收到AS-REQ消息时，TGS执行相同的身份验证和重放防御。智能合约提供身份验证并实现对重放攻击的抵御。

⑥　在解密和验证AS-REQ后，认证服务器(AS)通过AS- REP响应向客户端发出**TGT**票据。**TGT票据**允许客户端访问TGS以获得**ST**票据。

⑦　客户端将使用**TGT**票据置入TGS-REQ消息来访问TGS。TGS解密身份验证码和TGT票据，以验证客户端名称是否一致，以及时间戳是否在有效范围内等。如果满足，TGS通过区块链向客户端在TGS-REP响应中发出ST票据。

⑧　在接收到TGS-REP后，客户端将使用AP-REQ消息启动AP-EX。其中，AP-REQ中的身份验证码用于消息校验和和会话密钥传输。

⑨　如果验证成功，服务器将在AP-REP消息中包含一个临时会话密钥**K****session**进行响应。最后，服务会话顺利进行。

表2 DKSM符号表

| 名称    | 描述          |
| ------- | ------------- |
| KDC     | 密钥分发中心  |
| C       | 客户          |
| V       | 服务器        |
| AS      | 认证服务器    |
| TGS     | 票据服务器    |
| TGT     | 票据授予票据  |
| ST      | 服务票据      |
| REP/REQ | 请求/响应报文 |

## 2.2 详细设计

DKSM可以分为“初始化”，“认证服务交换”，“票据授予服务交换”，“双向认证交换”四部分。方案的符号表如表2所示，方案使用的所有密钥及其作用如表3所示。

表3 DKSM密钥表

| 名称             | 密钥种类 | 描述                     |
| ---------------- | -------- | ------------------------ |
| **K****C**       | AES-256  | 客户端AES密钥            |
| **K****TGS**     | AES-256  | TGS AES密钥              |
| **K****V**       | AES-256  | 服务端AES密钥            |
| **K****C,TGS**   | AES-256  | 客户端及TGS的会话密钥    |
| **K****C,V**     | AES-256  | 客户端及服务端的会话密钥 |
| **K****session** | AES-256  | 服务会话密钥             |
| **PK**           | CP-ABE   | 系统属性基公钥           |
| **MSK**          | CP-ABE   | 系统属性基主密钥         |
| **SK**           | CP-ABE   | 用户属性基私钥           |

### 2.2.1 初始化

l AES密钥生成：首先，每个用户（包括客户端和服务器）提供其ID和密码进行注册。用户的密钥是一个AES-256密钥，使用PBKDF2算法从密码和ID生成。

l 属性基密码创建：接下来，权威机构将生成一个基于密文属性的加密密钥对（**PK，MSK**），并从消息空间**M**中随机选择一条消息**m**。然后根据KDC设置的访问策略“**S**”对**KDC**进行加密。更多细节详见2.2.3节。验证者如果不具备必要的属性，那么他将无法获得正确的**KDC**来解密任何用户的密钥。

l 数据加密：与客户端和服务器不同，KDC负责管理所有用户的密钥，并需要将密钥公开存储在区块链上。与传统方案一致，DKSM使用**KDC**对所有用户的AES密钥和权限列表进行加密。不同之处在于，我们使用了一种基于密文策略属性的加密（CP-ABE）方案来实现对**KDC**的细粒度访问控制，这也同时在一定程度实现了去中心化。当提供了正确的属性时，将运行**KeyGen（MSK，S）**以获得用于解密的**SK**。

l 智能合约初始化：所设计的智能合约包括两个结构体：“User”和“Packet”，分别代表用户和其对应的报文，如表4，表4-4，表6所示。DKSM定义了一个用户id到Packet的映射，每个用户都有他对应发送的Packet（交换报文）。User用户结构被用于存储与用户的字符串ID相关联的公共信息。在DKSM中，ID相当于Kerberos中的“主体”。例如，在DKSM域中的Alice的ID是Alice@dksm.com。此外，User存储每个用户对应的随机数，用于识别消息重放。一旦部署了DKSM智能合同，KDC就可以调用算法1来上传用户的信息。

DKSM将KDC与智能合约结合，从而产生了一个包含区块链特征的增强Kerberos方案，不仅提供了分布式存储和消息可跟踪等好处，同时保护了数据隐私。

```
算法1 Initialization

Require: (ID, Address, EncKey, EncPL, lifetime**)
Output: True or False
1: if users[ID].id == null then
2:  users[ID].id = ID;
3:  users[ID].user =Address;
4:  users[ID].Key = EncKey;
5:  users[ID].PL = EncPL;
6:  users[ID].lifetime = lifetime;
7:  users[ID].nonce = uint256(keccak256(block.timestamp, block.number));
8:  users[ID].timestamp = block.timestamp;
9:  users[ID].islogin = False;
10: else
11:   return False;//User already exist
12: end if
13: return True;
```

 表4 DKSM智能合约中的主要数据结构

| 数据类型                | 变量名 | 内容                         |
| ----------------------- | ------ | ---------------------------- |
| struct                  | User   | The User structure           |
| struct                  | Packet | The Packet structure         |
| mapping(string => User) | users  | ID to User structure mapping |

表5 DKSM智能合约中的User数据结构

| 数据类型                  | 变量名        | 内容                              |
| ------------------------- | ------------- | --------------------------------- |
| address                   | **user**      | The User’s address                |
| string                    | **id**        | principal                         |
| string                    | **Key**       | Encrypted AES secret key          |
| string                    | **PL**        | Encrypted Permission List         |
| string                    | **lifetime**  | lifetime                          |
| uint256                   | nonce         | nonce for replay defense          |
| uint256                   | **timestamp** | user’s setup time                 |
| bool                      | islogin       | login state                       |
| mapping(string => Packet) | RepOrReq      | ID to Request or response mapping |

表6 DKSM智能合约中的Packet数据结构

| 数据类型 | 变量名        | 内容                     |
| -------- | ------------- | ------------------------ |
| address  | user          | The Originator’s address |
| string   | **IDfrom**    | principal                |
| string   | **IDto**      | principal                |
| uint     | **timestamp** | block.timestamp          |
| string   | REQorREP      | Exchange Message         |

接着，我们提出了一种基于区块链的时间同步方案，基于时间戳及随机数的概念抵御重放攻击，称为**BCTs-Nc。**该方案在每个报文上传/获取或交易的过程中运行。具体来说，我们基于区块链修改了传统Kerberos机制，结合了块数、块时间戳等特性。

时间戳检查：当消息上传到区块链进行存储时，智能合约将消息的时间戳设置为块时间戳**block.timestamp**（如算法3-2的第3行所示）。其核心思想在于存储时设置时间戳，并在用户检索报文时检查它。

随机数检查：在初始化过程中，在智能合约中设置随机数nonce，如算法4-2的第3行所示，并绑定到用户的地址。在发送消息时，每个用户必须获得一次nonce，并将其包含到报文中。接着，智能合约验证nonce是否与用户地址匹配。如果是，消息被成功接受，nonce自动增加1。如不匹配，则会拒绝该用户的上传操作。

```
算法2  BCTs-Nc for Time Synchronization and Nonce-check

Require: (IDfrom, IDto)
Output: True or False
1: while User set a message do
2: 	nonce_from = getnonce(IDfrom);
3:  users[IDfrom].ReqOrRep[IDto].timestamp = block.timestamp;
4:  if users[IDfrom].nonce == nonce_from
5:    Nonce_Check = True;
6:  else
7:    Nonce_Check = False;
8:  end if
9:  users[IDfrom].nonce += 1;
10: end while
11: while User get a message do
12:  nonce_to = getnonce(IDto);
13:  if users[IDto].nonce == nonce_to and localtime - message_time < 300 
14:   Nonce_Check = True;
15:   Time_Check = True;
16:  else
17:   Nonce_Check = False;
18:   Time_Check = False;
19:  end if
20: users[IDto].nonce += 1
21: end while
```

在所有用户成功注册之后，协议分别执行认证服务交换（AS-EX）、票证授予服务交换（TGS-EX）和双向认证交换（AP-EX）。

### 2.2.2 认证服务交换

当一个客户端想要访问一个特定的应用程序服务器时，它必须首先通过向KDC的认证服务器（AS）证明其身份，以获取凭据TGT。拿到TGT票据的客户端才能请求一个特定的服务。认证服务交换包含以下两个报文：

**1)** **AS-REQ** :={ ID_C || ID, TGS || Time-exp || Nonce|| Kc{TimeStamp}};

**AS-REQ**报文中包含了一个加密的时间戳以及客户端和TGS的标识等。客户端通过区块链帐户发送签名交易，保证交易是无法伪造的。智能合约会首先检查报文中的两个id是否存在于用户列表中，验证id到地址绑定以防止非法登录，并执行**BCTs-Nc**算法。

**2)** **AS-REP**:=Kc{KC,TGS || ID, TGS ||Time-exp ||Nonce || TimeStamp || TGT}; 

其中**TGT**登录验证成功后，身份验证服务器（AS）将包含**TGT**票据的**AS-REP**发送到客户端。变量**Kc,tgs**表示一个随机生成的AES密钥，它作为客户端和票证授予服务器（TGS）之间的会话密钥。AS通过向发送事务，在智能合约中存储**AS-REQ**消息。智能合约在存储**AS-REP**并将用户的登录状态设置为“True”之前，会验证报文的各个方面，如发送者地址、消息ID等。一旦客户端接收到**AS-REP**消息，解密成功后检查，如果消息中的时间戳在可接受的范围内，则认为身份验证成功。然后，客户端保存**TGT**和会话密钥，以便将来进行通信。否则，客户端将向AS发送一个错误消息。

### 2.2.3 票据授予服务交换

成功登录后，客户端可以申请访问特定的服务器。客户端和服务器之间的消息交换包括一个请求和响应。票据授予服务交换包含以下两个报文：

**1)** TGS-REQ := {ID_V, Time-exp, Nonce|| TGT || Authenticator1};

其中**Authenticator1**:= K_C, TGS{ID_C, CheckSum, TimeStamp}。

认证码“**Authenticator1**”向TGS证明客户端持有会话密钥，并提供（**ID_C, ID_V, TGT**）的校验和，以确保消息的完整性。同样地，当客户端发送事务时，智能合约会自动执行一系列检查。在从区块链获得**TGS-REQ**后，TGS解密了**Authenticator1**和**TGT**。如果**TGT**的生命周期在指定的范围内，并且认证码正确，则票证请求成功。最后，TGS将查找客户端的权限列表，以查看它是否有权访问该服务器。否则，交换失败，TGS将用“**KRB-ERR**”响应客户端。（如算法4所示）

```
算法3  TGS-EX

Require: (ID_C, ID_V, ID_KDC, TGT)
Output: SUCCESS or ERROR
1: Authenticator1 ← Enc_K_C,TGS(ID_C|| CheckSum || Timestamp
2: TGS-REQ ← ID_C || ID_V || TimeStamp || TGT || Authenticator1;
3: Await DKSM.CSetTGS-REQ(ID_C, ID_V, ID_KDC, Nonce_C, TGS-REQ);
4: TGS-REQ, CK_KDC ← Await DKSM.TGSGetTGS-REQ(ID_C, ID_V, ID_KDC);
5: if users[ID_C].TGSREQ[ID_TGS].content != null and ContentCheck() and CheckTGT()
6:  K_C,V ← GenRandKey();
7:  Decrypt TGT and get K_C,TGS
8:  K_V ← Dec(DKSM.TGSGet-CKv(ID_KDC, ID_V));
9:  K_C,V ← GenRandKey();
10:  ST_V ← EncKv(ID_C, ID_V, K_C,V lifetime);
11:  TGS-REP ← EncKc,tgs(K_C,V, ID_C ID_V ST_V , Nonce, TimeStamp);
12:  Await DKSM.SetTGS-REP(IDc, IDv, Nonce_TGS, TGS-REP);
13:  TGS-REP, TS-tgsrep ← Await DKSM.GetTGS-REP(IDc, IDv);
14:  if users[ID_C].TGSREP[ID_V].content ≠ null and ContentCheck()
15:   Decrypt and Get ST_V;
16:   return ST_V, K_C,V;
17:  else
18:   return ERROR;
19:  end if
20: else
21:  return ERROR;
22: end if
```

**2)** **TGS-REP**:= {Kc,tgs{K_c, v, ID_C, ID_V, ST, Time-exp, Nonce, TimeStamp}};

其中**ST**:=K_V{ID_C, ID_V, K_C,V, lifetime}

作为对**TGT**票据请求的响应，**TGS-REP**基于会话密钥**Kc,tgs**进行加密。服务票不仅包含由TGS随机生成的会话密钥**K_C,V**，还包含票的有效期。任何逾期门票均需重新申请签发。类似于**AS-REP**的接收，客户端解密消息并确认**TGS-REP**中的信息是可接受的（如算法3所示）。然后保存服务票证和会话密钥**K_C,V**，以便进行后续通信。如果对TGS-EX进程的任何验证出错，客户端将用“KRB-ERR”响应TGS。

### 2.2.4 双向认证交换

双向认证交换包含以下两个报文：

**1)** **AP-REQ**:={IDc, IDv, TimeStamp, ST || Authenticator2};

与**TGS-REQ**类似，客户端需要在**AP-REQ**中发送一个身份验证码**Authenticator2**。但是，在这种情况下，身份验证器包含由客户端生成的服务会话密钥**K_session**。如果服务票据在有效期内，并且身份验证码核验正确，则服务请求成功。TGS将保存**K_C,V**和**K_session**供进一步使用。如果发生任何错误，返回“KRB-ERR”。	

**2)**AP-REP:={Kc,v{IDc,IDv,TimeStamp};

服务器发送一个带有id和时间戳的响应，客户端在解密后进行检查。此外，智能合约不仅通过地址绑定ID来确保身份验证，而且还可以通过我们设计的**BCTs-Nc**算法实现重放检测。如果上述所有验证都通过，客户端和服务器之间的相互验证成功。然后，客户端和服务器可以使用临时会话密钥启动服务会话。如果任何步骤出现错误，服务器将使用“**KRB-ERR**”消息响应客户端。

```
算法4 AP-EX

Require: (ID_C, ID_V ST_V)Output: SUCCESS or ERROR
1: K_session ← GenRandKey();
2: Authenticator2 ← EncK_C,V(IDc || CheckSum || K_session || TimeStamp1);
3: AP_REQ = ID_C || ID_V || TimeStamp2 || ST_V || Authenticator2;
4: Await DKSM.CSetAP_REQ(ID_C, ID_V. Nonce_C, AP_REQ);
5: AP_REQ ← Await DKSM.VGetAP-REQ(ID_C, ID_V);
6: if users[ID_C].APREQ[ID_V].content != null and ContentCheck() and CheckST();
7: AP-REP ← EncKsession(ID_C || ID_V || TimeStamp);
8: Await DKSM.VSetAP-REP(ID_C , ID_V , Nonce_V, AP_-REP);
9: AP_REP ← Await DKSM.CGetAP-REP(ID_C , ID_V);
10:if users[ID_C].APREP[ID_V].content != null and ContentCheck() == True ;
11:Decrypt and Get K_session;
12:return K_session;
13: else
14:    return ERROR;
15:end if
16: else
17:   return ERROR;
18:end if
```



## 2.3 安全性分析

DKSM解决了Kerberos协议所面临的大部分安全挑战，以下是细节：

**1. 隐私性**。数据包在被加密后存储在智能合约中。因此，没有对称密钥的用户无法访问明文数据。其次，为了防止对称密钥在传输过程中被泄露，我们使用CP-ABE算法。客户端只有经过智能合约的认证和授权后才能获得TGT票据，每个用户的权限列表由服务所有者设置。并且，DID作为其身份验证解决方案。

**2. 细粒度访问控制**。为了防止在交易过程中被泄露，DKSM实现了CP-ABE算法，在多个属性之间共享**KDC**。只有具有正确属性，才能解密**密文信息。

**3. 重放攻击抵御**。重放攻击指攻击者拦截一条消息，并恶意将这条消息重新发送给消息接收方，以通过身份验证或在网络中实施欺诈行为。常见的抵御方式有加入时间因素或者一次性验证码等，加大重放成功的难度。我们提出了一个基于区块链的时间同步解决方案，称为**BCTs-Nc**。具体来说，我们利用区块链的各种特性，如区块链账户地址作为DID，块高度，时间戳等，智能合约根据块数和块时间戳随机生成一个变化因子，变化因子阻碍了重放攻击的成功进行。

**4. 中间人攻击抵御**。我们的方案通过使用签名机制和证书，有效地抵抗了中间人的攻击。用户进行的每笔交易都被链接到他们的帐户地址。即使攻击者窃取了消息，他们也将无法伪造交易，因为私钥是保密的。

**5. 白银票据和黄金票据攻击抵御**。白银票据，黄金票据分别指代服务票据ST和认证票据TGT。白银票据攻击：攻击者获取目标服务器的NTLM哈希值，以便伪造有效的ST票据，访问特定的服务；黄金票据攻击：攻击者获取域控krbtgt的密码哈希值，用于伪造TGT票据。我们的方案建立在区块链技术之上，为用户提供身份验证，有效地禁止凭证伪造。攻击者将无法伪造或窃取DKSM协议的票据。



# 3. 创新性说明

本文提出的去中心化 Kerberos 安全服务管理方案（DKSM）在多个方面具有显著的创新性，主要体现在以下几个方面：

1. 去中心化身份认证：

DKSM 引入了基于区块链账户地址的去中心化身份（DID）认证机制，替代了传统 Kerberos 中的集中化密钥分发中心（KDC）。这种去中心化的设计消除了单点故障问题，提高了系统的可用性和可靠性。

2. 高级加密标准（AES）和密文策略属性基加密（CP-ABE）结合：

DKSM 结合了 AES 和 CP-ABE 两种加密技术，既保证了数据传输的高效性，又提供了细粒度的访问控制。特别是采用了快速属性加密（FABEO）方案，该方案相比传统的 CP-ABE 方案，具有更短的密文和更高的加密解密效率。

3. 基于区块链的时间同步和随机数校验机制：

DKSM 设计了一种基于区块链的时间同步和随机数校验解决方案（BCTs-Nc），有效防止了重放攻击。通过利用区块链的不可篡改性和可追溯性，确保了时间戳和随机数的安全性，进一步提升了系统的防护能力。

4. 智能合约实现身份认证：

DKSM 通过智能合约实现身份认证和访问控制。智能合约的自动执行特性不仅提高了认证过程的效率，还减少了人为干预的可能性，确保了认证过程的公正性和透明性。

5. 跨平台的可移植性和成本效益：

DKSM 方案在两个区块链网络（Sepolia 和 FISCO）上的实验表明，该方案具有良好的可移植性和成本效益。特别是在 FISCO BCOS 平台上，各阶段的时间成本分析表明，DKSM 在性能和成本上具有显著优势，适用于实际应用场景。

6. 全面的安全防护：

DKSM 不仅解决了传统 Kerberos 协议中的密钥暴露和时间同步问题，还通过区块链和 CP-ABE 技术，提供了全面的安全防护。本文详细分析了 DKSM 在防止重放攻击、中间人攻击和票据伪造攻击等方面的优势，展示了其在安全性上的创新。

综上所述，本文提出的 DKSM 方案在去中心化身份认证、加密技术结合、时间同步和随机数校验、智能合约应用、跨平台可移植性以及全面安全防护等多个方面进行了创新，提供了一种高效、安全、可靠的分布式身份认证和访问控制解决方案，具有重要的理论意义和应用价值。
